/**
 * generated by Xtext
 */
package kieker.develop.rl.validation;

import java.util.Arrays;
import java.util.Collection;
import kieker.develop.rl.generator.InternalErrorException;
import org.eclipse.xtend.lib.Property;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Pair;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class RecordLangValidator /* implements AbstractRecordLangValidator  */{
  public final static String INVALID_NAME = "invalidName";
  
  /**
   * Check if an alias is a cyclic definition.
   */
  @Check
  public void checkCyclicAlias(final Property property) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field referTo is undefined for the type Property"
      + "\nThe method or field referTo is undefined for the type Property"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\n!= cannot be resolved"
      + "\nreferTo cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nPROPERTY__REFER_TO cannot be resolved"
      + "\nreferTo cannot be resolved");
  }
  
  /**
   * Check whether a property has been declared twice with different types.
   */
  @Check
  public Object checkPropertyDeclaration(final Property property) {
    throw new Error("Unresolved compilation problems:"
      + "\nRecordType cannot be resolved to a type."
      + "\nType cannot be resolved to a type."
      + "\nTemplateType cannot be resolved to a type."
      + "\nType cannot be resolved to a type."
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field name is undefined for the type Object"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\ncollectAllProperties cannot be resolved"
      + "\nexists cannot be resolved"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nfindFirst cannot be resolved"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nname cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nPROPERTY__NAME cannot be resolved"
      + "\ncollectAllProperties cannot be resolved"
      + "\nexists cannot be resolved"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nfindFirst cannot be resolved"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nname cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nPROPERTY__NAME cannot be resolved");
  }
  
  /**
   * Check a RecordType for multiple inheritance of the same property with different types.
   */
  @Check
  public void checkRecordTypeComposition(final /* RecordType */Object type) {
    throw new Error("Unresolved compilation problems:"
      + "\nType cannot be resolved to a type."
      + "\nType cannot be resolved to a type."
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\ncollectAllProperties cannot be resolved"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nCOMPLEX_TYPE__PARENTS cannot be resolved");
  }
  
  /**
   * Check a PartialType for multiple inheritance of the same property with different types.
   */
  @Check
  public void checkPartialTypeComposition(final /* TemplateType */Object type) {
    throw new Error("Unresolved compilation problems:"
      + "\nType cannot be resolved to a type."
      + "\nType cannot be resolved to a type."
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field eContainer is undefined for the type Property"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\ncollectAllProperties cannot be resolved"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nname cannot be resolved"
      + "\nname cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nCOMPLEX_TYPE__PARENTS cannot be resolved");
  }
  
  /**
   * Check it a given constant's type and the assigned value's type match.
   */
  @Check
  public Object checkConstantValueTyping(final /* Constant */Object constant) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\nThe method compareTypesInAssignment(Classifier, Classifier, Literal) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nvalue cannot be resolved"
      + "\n!= cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ncreateFQNTypeName cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ncreateFQNTypeName cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nCONSTANT__TYPE cannot be resolved");
  }
  
  /**
   * Check it a given property's type and the assigned value's type match.
   */
  @Check
  public Object checkPropertyValueTyping(final Property property) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field value is undefined for the type Property"
      + "\nThe method or field value is undefined for the type Property"
      + "\nThe method or field value is undefined for the type Property"
      + "\nThe method error(String, Object, String) is undefined"
      + "\nThe method or field value is undefined for the type Property"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\nThe method compareTypesInAssignment(Classifier, Classifier, Literal) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\n!= cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ncreateFQNTypeName cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ncreateFQNTypeName cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nPROPERTY__TYPE cannot be resolved");
  }
  
  /**
   * Check it a given type of one array element matches the other.
   */
  @Check
  public Object checkValueTyping(final /* ArrayLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method error(String, Object) is undefined"
      + "\nThe method or field RecordLangPackage.Literals is undefined"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThe method typeEquality(Classifier, Classifier) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nliterals cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n> cannot be resolved"
      + "\nliterals cannot be resolved"
      + "\nget cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nliterals cannot be resolved"
      + "\nforall cannot be resolved"
      + "\n! cannot be resolved"
      + "\nliterals cannot be resolved"
      + "\nmap cannot be resolved"
      + "\ncreateFQNTypeName cannot be resolved"
      + "\njoin cannot be resolved"
      + "\nLiterals cannot be resolved"
      + "\nARRAY_LITERAL__LITERALS cannot be resolved");
  }
  
  /**
   * Create a full qualified type name based on a classifier.
   * 
   * @param classifier the classifier where the FQN is computed for
   */
  private String createFQNTypeName(final /* Classifier */Object classifier) {
    throw new Error("Unresolved compilation problems:"
      + "\nType mismatch: cannot convert from Object to Iterable<?>"
      + "\nType mismatch: cannot convert from Object to Iterable<?>"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\n+ cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nmap cannot be resolved"
      + "\njoin cannot be resolved");
  }
  
  /**
   * Check if types are a exact match.
   */
  private boolean typeEquality(final /* Classifier */Object left, final /* Classifier */Object right) {
    throw new Error("Unresolved compilation problems:"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n== cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nget cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nget cannot be resolved"
      + "\nsize cannot be resolved");
  }
  
  /**
   * Compare two types for a type match in a value assignment.
   */
  private boolean compareTypesInAssignment(final /* Classifier */Object left, final /* Classifier */Object right, final /* Literal */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method compareClassifierTypesInAssignment(Classifier, Classifier, Literal) from the type RecordLangValidator refers to the missing type Classifier");
  }
  
  /**
   * Check if types match in an assignment.
   */
  private boolean compareClassifierTypesInAssignment(final /* Classifier */Object left, final /* Classifier */Object right, final /* Literal */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method compareClassifierTypeEquvalenceSet(Classifier, Classifier, Literal) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nsizes cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n== cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nget cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nget cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nget cannot be resolved"
      + "\nsize cannot be resolved"
      + "\n!= cannot be resolved");
  }
  
  /**
   * Check if the left and the right type are compatible. First check if they are identical. If
   * not use checkTypeEquivalenceSet to check for compatible types. This is required for constants values.
   */
  private boolean compareClassifierTypeEquvalenceSet(final /* Classifier */Object left, final /* Classifier */Object right, final /* Literal */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkTypeEquivalenceSet(Classifier, Classifier, Literal) from the type RecordLangValidator refers to the missing type Classifier"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved");
  }
  
  /**
   * Check if types match.
   */
  private boolean checkTypeEquivalenceSet(final /* Classifier */Object left, final /* Classifier */Object right, final /* Literal */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nFloatLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nIntLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nThe method or field FloatLiteral is undefined"
      + "\nThe method or field IntLiteral is undefined"
      + "\nThe method or field IntLiteral is undefined"
      + "\nThe method or field IntLiteral is undefined"
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nThe method checkAllLiteralsArtOfType(Class<? extends Literal>, ArrayLiteral) from the type RecordLangValidator refers to the missing type Literal"
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nThe method checkAllLiteralsArtOfType(Class<? extends Literal>, ArrayLiteral) from the type RecordLangValidator refers to the missing type Literal"
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nThe method checkAllLiteralsArtOfType(Class<? extends Literal>, ArrayLiteral) from the type RecordLangValidator refers to the missing type Literal"
      + "\nUnreachable code: The if condition can never match. It is already handled by a previous condition."
      + "\nThe method checkAllLiteralsArtOfType(Class<? extends Literal>, ArrayLiteral) from the type RecordLangValidator refers to the missing type Literal"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n>= cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n<= cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n>= cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n<= cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\ntype cannot be resolved"
      + "\nname cannot be resolved"
      + "\nequals cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n>= cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nvalue cannot be resolved"
      + "\n<= cannot be resolved");
  }
  
  /**
   * Check in depth if all elements match the specific type.
   */
  private boolean checkAllLiteralsArtOfType(final /* Class<? extends Literal> */Object type, final /* ArrayLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nArrayLiteral cannot be resolved to a type."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThe method checkAllLiteralsArtOfType(Class<? extends Literal>, ArrayLiteral) from the type RecordLangValidator refers to the missing type Literal"
      + "\nliterals cannot be resolved"
      + "\nforall cannot be resolved");
  }
  
  /**
   * Compute the classifier for a literal.
   */
  private /* Classifier */Object _getType(final /* StringLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method createPrimitiveClassifier(BaseType) from the type RecordLangValidator refers to the missing type Object"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nThe method createPrimitiveClassifier(BaseType) from the type RecordLangValidator refers to the missing type Object"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nvalue cannot be resolved"
      + "\nlength cannot be resolved"
      + "\n!= cannot be resolved");
  }
  
  private /* Classifier */Object _getType(final /* IntLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method createPrimitiveClassifier(BaseType) from the type RecordLangValidator refers to the missing type Object"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier");
  }
  
  private /* Classifier */Object _getType(final /* FloatLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method createPrimitiveClassifier(BaseType) from the type RecordLangValidator refers to the missing type Object"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier");
  }
  
  private /* Classifier */Object _getType(final /* BooleanLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method createPrimitiveClassifier(BaseType) from the type RecordLangValidator refers to the missing type Object"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier");
  }
  
  private /* Classifier */Object _getType(final /* ConstantLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nvalue cannot be resolved"
      + "\ntype cannot be resolved");
  }
  
  private /* Classifier */Object _getType(final /* BuiltInValueLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method createPrimitiveClassifier(BaseType) from the type RecordLangValidator refers to the missing type Object"
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nvalue cannot be resolved");
  }
  
  private /* Classifier */Object _getType(final /* ArrayLiteral */Object literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nRecordLangFactory.eINSTANCE cannot be resolved to a type."
      + "\nThe method getType(StringLiteral) from the type RecordLangValidator refers to the missing type Classifier"
      + "\nliterals cannot be resolved"
      + "\nget cannot be resolved"
      + "\neINSTANCE cannot be resolved"
      + "\ncreateArraySize cannot be resolved"
      + "\nsetSize cannot be resolved"
      + "\nliterals cannot be resolved"
      + "\nsize cannot be resolved"
      + "\nsizes cannot be resolved"
      + "\nadd cannot be resolved");
  }
  
  private /* Classifier */Object _getType(final /* Literal */Object literal) {
    try {
      throw new InternalErrorException("Unhandled literal type");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  private Object createPrimitiveClassifier(final /* BaseType */Object type) {
    throw new Error("Unresolved compilation problems:"
      + "\nRecordLangFactory cannot be resolved to a type."
      + "\neINSTANCE cannot be resolved"
      + "\ncreateClassifier cannot be resolved"
      + "\nsetType cannot be resolved");
  }
  
  /**
   * -- service routines --
   */
  private Pair<Property, Property> findDuplicate(final Property property, final Collection<Property> properties) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field name is undefined for the type Property"
      + "\nThe method or field name is undefined for the type Property"
      + "\nequals cannot be resolved"
      + "\n&& cannot be resolved");
  }
  
  private Classifier getType(final StringLiteral literal) {
    if (literal != null) {
      return _getType(literal); else {
        throw new IllegalArgumentException("Unhandled parameter types: " +
          Arrays.<Object>asList(literal).toString());
      }
    }
  }
  