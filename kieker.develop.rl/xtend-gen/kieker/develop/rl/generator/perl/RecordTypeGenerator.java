package kieker.develop.rl.generator.perl;

import com.google.common.base.Objects;
import java.io.File;
import java.util.Collection;
import java.util.List;
import kieker.develop.rl.generator.AbstractRecordTypeGenerator;
import kieker.develop.rl.recordLang.BaseType;
import kieker.develop.rl.recordLang.Classifier;
import kieker.develop.rl.recordLang.Model;
import kieker.develop.rl.recordLang.Property;
import kieker.develop.rl.recordLang.RecordType;
import kieker.develop.rl.recordLang.Type;
import kieker.develop.rl.typing.PropertyResolution;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

@SuppressWarnings("all")
public class RecordTypeGenerator extends AbstractRecordTypeGenerator {
  /**
   * Return the unique id.
   */
  @Override
  public String getId() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("perl");
    return _builder.toString();
  }
  
  /**
   * Return the preferences activation description.
   */
  @Override
  public String getDescription() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("Perl record generator");
    return _builder.toString();
  }
  
  /**
   * No perl structures for abstract record types.
   */
  @Override
  public boolean supportsAbstractRecordType() {
    return false;
  }
  
  /**
   * Compute the directory name for a record type.
   */
  @Override
  public CharSequence getDirectoryName(final Type type) {
    StringConcatenation _builder = new StringConcatenation();
    EObject _eContainer = type.eContainer();
    String _name = ((Model) _eContainer).getName();
    String _replace = _name.replace(".", File.separator);
    _builder.append(_replace, "");
    return _builder;
  }
  
  /**
   * Return the extension used for the file type generated by this generator.
   */
  @Override
  public String getFileName(final Type type) {
    StringConcatenation _builder = new StringConcatenation();
    CharSequence _directoryName = this.getDirectoryName(type);
    _builder.append(_directoryName, "");
    _builder.append(File.separator, "");
    String _name = type.getName();
    _builder.append(_name, "");
    _builder.append(".pm");
    return _builder.toString();
  }
  
  @Override
  public String getOutletType() {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("perl");
    return _builder.toString();
  }
  
  /**
   * Create a perl based record for kieker
   */
  @Override
  public CharSequence generate(final RecordType type) {
    CharSequence _xblockexpression = null;
    {
      String _xifexpression = null;
      String _author = type.getAuthor();
      boolean _equals = Objects.equal(_author, null);
      if (_equals) {
        _xifexpression = this.getAuthor();
      } else {
        _xifexpression = type.getAuthor();
      }
      final String definedAuthor = _xifexpression;
      String _xifexpression_1 = null;
      String _since = type.getSince();
      boolean _equals_1 = Objects.equal(_since, null);
      if (_equals_1) {
        _xifexpression_1 = this.getVersion();
      } else {
        _xifexpression_1 = type.getSince();
      }
      final String definedVersion = _xifexpression_1;
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("use strict;");
      _builder.newLine();
      _builder.append("use warnings;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("package ");
      CharSequence _recordName = this.recordName(type);
      _builder.append(_recordName, "");
      _builder.append(";");
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("=head1 NAME");
      _builder.newLine();
      _builder.newLine();
      CharSequence _recordName_1 = this.recordName(type);
      _builder.append(_recordName_1, "");
      _builder.append(" ");
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("=head1 SYNOPSIS");
      _builder.newLine();
      _builder.newLine();
      _builder.append(" ");
      _builder.append("my $record = ");
      CharSequence _recordName_2 = this.recordName(type);
      _builder.append(_recordName_2, " ");
      _builder.append("->new(");
      List<Property> _collectAllDataProperties = PropertyResolution.collectAllDataProperties(type);
      String _createParameterCall = this.createParameterCall(_collectAllDataProperties);
      _builder.append(_createParameterCall, " ");
      _builder.append(");");
      _builder.newLineIfNotEmpty();
      _builder.append(" ");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("$writer->write($record->genoutput());");
      _builder.newLine();
      _builder.newLine();
      _builder.append("=head1 DESCRIPTION");
      _builder.newLine();
      _builder.newLine();
      _builder.append("Auto-generated structures.");
      _builder.newLine();
      _builder.append("Author: ");
      _builder.append(definedAuthor, "");
      _builder.newLineIfNotEmpty();
      _builder.append("Since: ");
      _builder.append(definedVersion, "");
      _builder.newLineIfNotEmpty();
      _builder.append("\t\t");
      _builder.newLine();
      _builder.append("=head1 METHODS");
      _builder.newLine();
      _builder.newLine();
      _builder.append("=head2 $record = ");
      CharSequence _recordName_3 = this.recordName(type);
      _builder.append(_recordName_3, "");
      _builder.append("->new(");
      List<Property> _collectAllDataProperties_1 = PropertyResolution.collectAllDataProperties(type);
      String _createParameterCall_1 = this.createParameterCall(_collectAllDataProperties_1);
      _builder.append(_createParameterCall_1, "");
      _builder.append(");");
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("Creates a new record with the given parameters.");
      _builder.newLine();
      _builder.newLine();
      _builder.append("=cut");
      _builder.newLine();
      _builder.newLine();
      _builder.append("sub new {");
      _builder.newLine();
      _builder.append("  ");
      _builder.append("my (");
      List<Property> _collectAllDataProperties_2 = PropertyResolution.collectAllDataProperties(type);
      String _createParameterCall_2 = this.createParameterCall(_collectAllDataProperties_2);
      _builder.append(_createParameterCall_2, "  ");
      _builder.append(") = @_;");
      _builder.newLineIfNotEmpty();
      _builder.append("  ");
      _builder.append("my $this = {");
      _builder.newLine();
      _builder.append("    ");
      List<Property> _collectAllDataProperties_3 = PropertyResolution.collectAllDataProperties(type);
      final Function1<Property, CharSequence> _function = (Property it) -> {
        return this.createProperty(it);
      };
      List<CharSequence> _map = ListExtensions.<Property, CharSequence>map(_collectAllDataProperties_3, _function);
      String _join = IterableExtensions.join(_map, ",\n");
      _builder.append(_join, "    ");
      _builder.newLineIfNotEmpty();
      _builder.append("  ");
      _builder.append("};");
      _builder.newLine();
      _builder.newLine();
      _builder.append("  ");
      _builder.append("return bless($this,$type);");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.newLine();
      _builder.append("=head2 $string = $record->genoutput();");
      _builder.newLine();
      _builder.newLine();
      _builder.append("Serializes the record for output. Returns the serialized form of the record.");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.newLine();
      _builder.append("=head1 COPYRIGHT and LICENCE");
      _builder.newLine();
      _builder.newLine();
      String _header = this.getHeader();
      _builder.append(_header, "");
      _builder.newLineIfNotEmpty();
      _builder.newLine();
      _builder.append("=cut");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  /**
   * Create perl type names.
   * Most likely this routine is never used, as perl sucks in typing.
   */
  public String createTypeName(final Classifier classifier) {
    String _switchResult = null;
    BaseType _type = classifier.getType();
    String _name = _type.getName();
    switch (_name) {
      case "string":
        _switchResult = "String";
        break;
      default:
        BaseType _type_1 = classifier.getType();
        _switchResult = _type_1.getName();
        break;
    }
    return _switchResult;
  }
  
  /**
   * Create one property for the type declaration.
   */
  public CharSequence createProperty(final Property property) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = property.getName();
    _builder.append(_name, "");
    _builder.append(" => $");
    String _name_1 = property.getName();
    _builder.append(_name_1, "");
    return _builder;
  }
  
  /**
   * Compute the absolute Perl package name, which is a FQN name of the record.
   */
  public CharSequence recordName(final RecordType type) {
    StringConcatenation _builder = new StringConcatenation();
    EObject _eContainer = type.eContainer();
    String _name = ((Model) _eContainer).getName();
    String _replace = _name.replace(".", "::");
    _builder.append(_replace, "");
    _builder.append("::");
    String _name_1 = type.getName();
    _builder.append(_name_1, "");
    return _builder;
  }
  
  public String createParameterCall(final Collection<Property> list) {
    final Function1<Property, String> _function = (Property it) -> {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("$");
      String _name = it.getName();
      _builder.append(_name, "");
      return _builder.toString();
    };
    Iterable<String> _map = IterableExtensions.<Property, String>map(list, _function);
    return IterableExtensions.join(_map, ", ");
  }
}
