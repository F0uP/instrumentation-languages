package kieker.develop.rl.generator.perl

import kieker.develop.rl.recordLang.Type
import kieker.develop.rl.recordLang.RecordType
import kieker.develop.rl.recordLang.Classifier
import kieker.develop.rl.recordLang.Model
import kieker.develop.rl.recordLang.Property
import java.io.File
import kieker.develop.rl.generator.AbstractRecordTypeGenerator
import java.util.Collection

import static extension kieker.develop.rl.typing.PropertyResolution.*


class RecordTypeGenerator extends AbstractRecordTypeGenerator {

	/**
	 * Return the unique id.
	 */
	override getId() '''perl'''
	
	/**
	 * Return the preferences activation description.
	 */
	override getDescription() '''Perl record generator'''
	
	/**
	 * No perl structures for abstract record types.
	 */
	override boolean supportsAbstractRecordType()  { false }

	/**
	 * Compute the directory name for a record type.
	 */
	override getDirectoryName(Type type) '''«(type.eContainer as Model).name.replace('.',File::separator)»'''
		
	/**
	 * Return the extension used for the file type generated by this generator. 
	 */
	override getFileName(Type type) '''«type.getDirectoryName»«File::separator»«type.name».pm'''
		
	override getOutletType() '''perl'''
	
	/**
	 * Create a perl based record for kieker
	 */
	override generate(RecordType type) {
		val definedAuthor = if (type.author == null) author else type.author
		val definedVersion = if (type.since == null) version else type.since
		'''
		use strict;
		use warnings;
		
		package «type.recordName»;
		
		=head1 NAME
		
		«type.recordName» 
		
		=head1 SYNOPSIS
		
		 my $record = «type.recordName»->new(«type.collectAllDataProperties.createParameterCall»);
		 
		 $writer->write($record->genoutput());
		
		=head1 DESCRIPTION
		
		Auto-generated structures.
		Author: «definedAuthor»
		Since: «definedVersion»
				
		=head1 METHODS
		
		=head2 $record = «type.recordName»->new(«type.collectAllDataProperties.createParameterCall»);
		
		Creates a new record with the given parameters.
		
		=cut
		
		sub new {
		  my («type.collectAllDataProperties.createParameterCall») = @_;
		  my $this = {
		    «type.collectAllDataProperties.map[createProperty].join(',\n')»
		  };
		
		  return bless($this,$type);
		}
		
		=head2 $string = $record->genoutput();
		
		Serializes the record for output. Returns the serialized form of the record.
						
		=head1 COPYRIGHT and LICENCE
		
		«header»
		
		=cut
		'''
	}
	
	/**
	 * Create perl type names.
	 * Most likely this routine is never used, as perl sucks in typing.
	 */
	def createTypeName(Classifier classifier) {
		switch (classifier.type.name) {
			case 'string' : 'String'
			default : classifier.type.name
		}
	}
	
	/**
	 * Create one property for the type declaration.
	 */
	def createProperty(Property property) '''«property.name» => $«property.name»'''
	
	/**
	 * Compute the absolute Perl package name, which is a FQN name of the record.
	 */
	def recordName(RecordType type) '''«(type.eContainer as Model).name.replace('.','::')»::«type.name»'''
		
	/**
	 * 
	 */
	def createParameterCall(Collection<Property> list) {
		list.map['''$«name»'''].join(', ')
	}
	
	
}